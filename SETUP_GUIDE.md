# Stackfluence — Setup & Deployment Guide

## Overview

This guide covers everything from local development to production deployment. The system has three layers:

1. **The FastAPI backend** — redirect service, event ingestion, link management
2. **PostgreSQL** — append-only event store + entity tables
3. **Redis** — rate limiting and caching (optional for MVP, required for production)

---

## Part 1: Local Development Setup

### Prerequisites

Install these on your machine:

- **Python 3.12+** — `brew install python@3.12` (macOS) or [python.org](https://www.python.org/downloads/)
- **Docker Desktop** — [docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop/) (for Postgres + Redis)
- **Git** — you likely have this already

### Step-by-Step Local Setup

**1. Clone and enter the project:**

```bash
cd ~/Projects  # or wherever you keep code
# If starting from the files I gave you:
mv stackfluence ~/Projects/stackfluence
cd ~/Projects/stackfluence
git init
```

**2. Create a Python virtual environment:**

```bash
python3.12 -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate
pip install -r requirements.txt
```

**3. Start Postgres and Redis via Docker:**

You don't need to Dockerize the app itself for local dev — just the databases:

```bash
# Start only the db and redis services (not the app)
docker-compose up -d db redis
```

This gives you:
- Postgres at `localhost:5432` (user: `stackfluence`, pass: `stackfluence`, db: `stackfluence`)
- Redis at `localhost:6379`

**4. Configure environment:**

```bash
cp .env.example .env
```

Edit `.env`:

```env
SF_CLICK_ID_SECRET=generate-a-real-secret-use-this-command-below
SF_DATABASE_URL=postgresql+asyncpg://stackfluence:stackfluence@localhost:5432/stackfluence
SF_REDIS_URL=redis://localhost:6379/0
SF_BASE_URL=http://localhost:8000
SF_DEBUG=true
```

Generate a proper secret:

```bash
python -c "import secrets; print(secrets.token_urlsafe(32))"
```

**5. Run database migrations:**

We need to set up Alembic first (one-time):

```bash
pip install alembic
alembic init alembic
```

Then edit `alembic/env.py` — replace the target_metadata line:

```python
# Add these imports at the top
from app.models.tables import Base
from app.config import get_settings

# Set the target metadata
target_metadata = Base.metadata

# Set the database URL
config.set_main_option("sqlalchemy.url", get_settings().database_url.replace("+asyncpg", ""))
```

Also install the sync Postgres driver (Alembic needs it):

```bash
pip install psycopg2-binary
```

Generate and run the initial migration:

```bash
alembic revision --autogenerate -m "initial schema"
alembic upgrade head
```

**6. Run the server:**

```bash
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

You should see:

```
INFO:     Uvicorn running on http://0.0.0.0:8000
INFO:     Started reloader process
```

**7. Verify it works:**

```bash
# Health check
curl http://localhost:8000/health
# → {"status":"ok","service":"stackfluence"}

# API docs (auto-generated by FastAPI)
open http://localhost:8000/docs
```

**8. Run tests:**

```bash
python -m pytest tests/ -v
```

### Local Dev Workflow

After initial setup, your daily workflow is:

```bash
cd ~/Projects/stackfluence
source .venv/bin/activate
docker-compose up -d db redis          # if not already running
uvicorn app.main:app --reload --port 8000
```

---

## Part 2: Testing the Full Click Flow Locally

**1. Seed test data** — create an org, creator, campaign, and link:

```bash
# You'll need to create seed data. Here's a quick script:
python -c "
import asyncio
from uuid import uuid4
from app.models.database import engine, async_session
from app.models.tables import Base, Organization, Creator, Campaign, Link

async def seed():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    async with async_session() as db:
        org = Organization(name='Test Brand', slug='testbrand')
        db.add(org)
        await db.flush()

        creator = Creator(handle='emma', display_name='Emma Smith', platform='instagram')
        db.add(creator)
        await db.flush()

        campaign = Campaign(organization_id=org.id, name='Summer Drop', slug='summer-drop')
        db.add(campaign)
        await db.flush()

        link = Link(
            organization_id=org.id,
            creator_id=creator.id,
            campaign_id=campaign.id,
            creator_handle='emma',
            campaign_slug='summer-drop',
            destination_url='https://example.com/collection',
        )
        db.add(link)
        await db.commit()
        print(f'✅ Seeded! Test link: http://localhost:8000/c/emma/summer-drop')

asyncio.run(seed())
"
```

**2. Test the redirect:**

```bash
curl -v http://localhost:8000/c/emma/summer-drop
```

You should see a `302` redirect to `https://example.com/collection?inf_click_id=<signed_id>`.

**3. Test event ingestion** (simulating the advertiser snippet):

```bash
# Grab the click_id from the redirect response, then:
CLICK_ID="<paste_click_id_here>"
ORG_ID="<paste_org_id_here>"

curl -X POST http://localhost:8000/v1/events/session \
  -H "Content-Type: application/json" \
  -d "{\"inf_click_id\": \"$CLICK_ID\", \"organization_id\": \"$ORG_ID\", \"page_url\": \"https://brand.com/collection\"}"

curl -X POST http://localhost:8000/v1/events/conversion \
  -H "Content-Type: application/json" \
  -d "{\"inf_click_id\": \"$CLICK_ID\", \"organization_id\": \"$ORG_ID\", \"event_type\": \"purchase\", \"order_id\": \"ORD-001\", \"revenue_cents\": 4999}"
```

---

## Part 3: Production Deployment

### Recommended Stack

| Component | Service | Why |
|-----------|---------|-----|
| **FastAPI app** | **Railway** or **Render** | Simple container deploys, auto-scaling, easy env vars. Both support Docker. |
| **PostgreSQL** | **Neon** (serverless) or **Supabase** | Free tier to start, scales well, branching for dev/staging. |
| **Redis** | **Upstash** (serverless) | Pay-per-request, zero maintenance, great free tier. |
| **Domain + DNS** | **Cloudflare** | Free CDN, DDoS protection, edge caching for redirect latency. |
| **Monitoring** | **Sentry** (errors) + **Better Stack** (logs) | Both have generous free tiers. |

### Why Not Vercel?

You know Vercel well from casesim, but it's optimized for frontend/serverless functions, not long-running Python servers. The redirect service needs a persistent process with connection pooling to Postgres and Redis. Railway or Render are better fits here.

### Production Deploy — Railway (Recommended)

Railway is the simplest path from "works locally" to "works in production."

**1. Install Railway CLI:**

```bash
brew install railway  # macOS
# or: npm install -g @railway/cli
```

**2. Create project and link:**

```bash
cd ~/Projects/stackfluence
railway login
railway init  # creates a new Railway project
```

**3. Add Postgres and Redis:**

In the Railway dashboard (railway.app):
- Click **+ New** → **Database** → **PostgreSQL**
- Click **+ New** → **Database** → **Redis**

Railway auto-provisions both and gives you connection strings.

**4. Set environment variables:**

```bash
railway variables set SF_CLICK_ID_SECRET=$(python -c "import secrets; print(secrets.token_urlsafe(32))")
railway variables set SF_DATABASE_URL=$RAILWAY_DATABASE_URL  # Railway provides this
railway variables set SF_REDIS_URL=$RAILWAY_REDIS_URL
railway variables set SF_BASE_URL=https://stackfluence.com
railway variables set SF_DEBUG=false
```

Note: Railway exposes `DATABASE_URL` and `REDIS_URL` automatically. You'll map them in the Railway dashboard under **Variables** → **Reference Variables**.

**5. Deploy:**

```bash
railway up
```

Railway reads your `Dockerfile`, builds, and deploys. Your service is live at a Railway-provided URL like `stackfluence-production.up.railway.app`.

**6. Custom domain:**

In Railway dashboard → your service → **Settings** → **Domains** → add `api.stackfluence.com`. Railway gives you a CNAME to point your DNS to.

### Production Deploy — Render (Alternative)

If you prefer Render:

**1.** Push your code to GitHub.

**2.** Go to [render.com](https://render.com) → **New Web Service** → connect your repo.

**3.** Settings:
- **Environment**: Docker
- **Instance type**: Starter ($7/mo) or Standard ($25/mo)
- **Region**: Oregon (us-west) or Virginia (us-east)

**4.** Add a Render PostgreSQL database and Redis instance.

**5.** Set environment variables in the Render dashboard.

**6.** Render auto-deploys on push to `main`.

### Database: Neon (Serverless Postgres)

If you want to separate the database from your compute provider:

**1.** Sign up at [neon.tech](https://neon.tech) — free tier gives you 0.5 GB.

**2.** Create a project → copy the connection string.

**3.** Replace `+asyncpg` in the Neon connection string:
```
# Neon gives you:
postgresql://user:pass@ep-xxx.us-east-2.aws.neon.tech/stackfluence

# You need:
postgresql+asyncpg://user:pass@ep-xxx.us-east-2.aws.neon.tech/stackfluence?ssl=require
```

**4.** Set this as `SF_DATABASE_URL` in your deploy environment.

### Redis: Upstash (Serverless Redis)

**1.** Sign up at [upstash.com](https://upstash.com) — free tier gives you 10k commands/day.

**2.** Create a database → copy the Redis URL.

**3.** Set as `SF_REDIS_URL`.

---

## Part 4: Domain & DNS Setup

### Domain Structure

| Domain | Purpose |
|--------|---------|
| `stackfluence.com` | Marketing site / landing page |
| `api.stackfluence.com` | FastAPI backend (redirects + API) |
| `app.stackfluence.com` | Dashboard frontend (future, React on Vercel) |
| `go.brand.com` | CNAME tracking domain per client (future optimization) |

### Cloudflare Setup

**1.** Register `stackfluence.com` (Cloudflare Registrar, Namecheap, or Google Domains).

**2.** Add the domain to Cloudflare (free plan is fine).

**3.** DNS records:

```
CNAME  api   →  your-railway-or-render-url.com    (proxied ☁️)
CNAME  app   →  cname.vercel-dns.com              (proxied ☁️)  [future]
A      @     →  your landing page IP               (proxied ☁️)
```

**4.** Cloudflare settings for the redirect service:
- **SSL/TLS**: Full (strict)
- **Caching**: Create a rule to bypass cache for `/c/*` paths (redirects must not be cached)
- **Page Rule**: `api.stackfluence.com/c/*` → Cache Level: Bypass
- **Rate Limiting** (optional): Cloudflare's built-in rate limiting as an additional layer

### Important: Redirect Caching

The `/c/*` redirect endpoints must NEVER be cached, because each click needs a unique `click_id`. Ensure your Cloudflare cache rules exclude these paths.

The `/v1/*` API endpoints also shouldn't be cached (POST requests aren't cached by default, but be explicit).

---

## Part 5: Production Checklist

### Before Launch

- [ ] **Generate a real `SF_CLICK_ID_SECRET`** — at least 32 bytes of randomness
- [ ] **Run Alembic migrations** against production database
- [ ] **Set `SF_DEBUG=false`** in production
- [ ] **Tighten CORS** in `app/main.py` — replace `allow_origins=["*"]` with your actual domains
- [ ] **Add API authentication** — the `/v1/links` and `/v1/events` endpoints need API keys per org
- [ ] **Set up Sentry** for error tracking: `pip install sentry-sdk[fastapi]`
- [ ] **Add health check monitoring** — point Better Stack or UptimeRobot at `/health`
- [ ] **Enable HTTPS** — handled automatically by Railway/Render/Cloudflare
- [ ] **Test the full flow** — create link → click → session → conversion → verify in database
- [ ] **Backups** — Neon auto-backs up; Railway Postgres needs manual config

### Security Hardening (Do Before Real Traffic)

- [ ] Add API key middleware for advertiser-facing endpoints
- [ ] Add rate limiting middleware (Redis-backed)
- [ ] Add request logging with correlation IDs
- [ ] Strip `X-Powered-By` and other fingerprint headers
- [ ] Set `Referrer-Policy: no-referrer` on redirect responses
- [ ] Add input validation for destination URLs (prevent open redirect attacks)

### Monitoring

- [ ] Sentry for exceptions
- [ ] Structured logs → Better Stack / Datadog
- [ ] Uptime monitoring on `/health`
- [ ] Alert on redirect latency > 200ms (p95)
- [ ] Alert on bot_blocked rate spikes

---

## Part 6: Cost Estimates

### Starting Out (< 100k clicks/month)

| Service | Cost |
|---------|------|
| Railway (Hobby) | $5/mo |
| Railway Postgres | $5/mo |
| Upstash Redis | Free |
| Cloudflare | Free |
| Sentry | Free tier |
| Domain | ~$12/yr |
| **Total** | **~$10–15/mo** |

### Growing (100k–1M clicks/month)

| Service | Cost |
|---------|------|
| Railway (Pro) | $20/mo |
| Neon Postgres (Scale) | $19/mo |
| Upstash Redis (Pay-as-you-go) | $5–10/mo |
| Cloudflare Pro (optional) | $20/mo |
| Sentry (Team) | $26/mo |
| **Total** | **~$90–100/mo** |

At $0.03–0.05 per QIS, even 50k qualified sessions/month = $1,500–2,500 revenue, so margins are strong.

---

## Quick Reference Commands

```bash
# --- Local Dev ---
source .venv/bin/activate
docker-compose up -d db redis
uvicorn app.main:app --reload --port 8000
python -m pytest tests/ -v

# --- Database ---
alembic revision --autogenerate -m "describe change"
alembic upgrade head
alembic downgrade -1  # rollback one

# --- Deploy (Railway) ---
railway up
railway logs
railway variables set KEY=VALUE

# --- Useful ---
python -c "import secrets; print(secrets.token_urlsafe(32))"  # generate secret
curl http://localhost:8000/docs  # interactive API docs
```
